package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"net"
	"net/http"
	"os"
	"strings"
	"time"
)

// loadDHCPConfig loads the DHCP configuration from JSON file
func loadDHCPConfig() (*DHCPConfigStore, error) {
	store := &DHCPConfigStore{
		Configs: make(map[string]DHCPConfig),
	}

	data, err := os.ReadFile(dhcpConfigPath)
	if err != nil {
		if os.IsNotExist(err) {
			// File doesn't exist yet, return empty store
			return store, nil
		}
		return nil, err
	}

	if err := json.Unmarshal(data, store); err != nil {
		return nil, err
	}

	return store, nil
}

// saveDHCPConfig saves the DHCP configuration to JSON file
func saveDHCPConfig(store *DHCPConfigStore) error {
	data, err := json.MarshalIndent(store, "", "  ")
	if err != nil {
		return err
	}

	// Ensure directory exists
	os.MkdirAll("/etc/softrouter", 0755)

	return os.WriteFile(dhcpConfigPath, data, 0644)
}

// validateIPRange checks if the IP range is valid and within the interface subnet
func validateIPRange(interfaceName, startIP, endIP, gateway string) error {
	// Get interface IP to determine subnet
	iface, err := net.InterfaceByName(interfaceName)
	if err != nil {
		return fmt.Errorf("interface not found: %v", err)
	}

	addrs, err := iface.Addrs()
	if err != nil || len(addrs) == 0 {
		return fmt.Errorf("interface has no IP address assigned")
	}

	// Find the first IPv4 address
	var interfaceNet *net.IPNet
	for _, addr := range addrs {
		if ipnet, ok := addr.(*net.IPNet); ok && ipnet.IP.To4() != nil {
			interfaceNet = ipnet
			break
		}
	}

	if interfaceNet == nil {
		return fmt.Errorf("interface has no IPv4 address")
	}

	// Parse and validate IPs
	startIPParsed := net.ParseIP(startIP)
	endIPParsed := net.ParseIP(endIP)
	gatewayParsed := net.ParseIP(gateway)

	if startIPParsed == nil || endIPParsed == nil || gatewayParsed == nil {
		return fmt.Errorf("invalid IP address format")
	}

	// Check if IPs are in the subnet
	if !interfaceNet.Contains(startIPParsed) {
		return fmt.Errorf("start IP %s is not in interface subnet %s", startIP, interfaceNet.String())
	}
	if !interfaceNet.Contains(endIPParsed) {
		return fmt.Errorf("end IP %s is not in interface subnet %s", endIP, interfaceNet.String())
	}
	if !interfaceNet.Contains(gatewayParsed) {
		return fmt.Errorf("gateway %s is not in interface subnet %s", gateway, interfaceNet.String())
	}

	return nil
}

// ARPEntry represents a row in /proc/net/arp
type ARPEntry struct {
	IP       string `json:"ip"`
	MAC      string `json:"mac"`
	Device   string `json:"device"`
	Hostname string `json:"hostname"` // Enriched data
	IsStatic bool   `json:"is_static"`
	IsActive bool   `json:"is_active"` // In ARP table
	Expires  string `json:"expires"`   // For DHCP leases
}

// getARPTable parses /proc/net/arp
func getARPTable() ([]ARPEntry, error) {
	file, err := os.Open("/proc/net/arp")
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var entries []ARPEntry
	scanner := bufio.NewScanner(file)
	scanner.Scan() // Skip header

	for scanner.Scan() {
		fields := strings.Fields(scanner.Text())
		if len(fields) < 6 {
			continue
		}
		// IP HWType Flags HWAddr Mask Device
		// 192.168.1.50 0x1 0x2 00:11:22:33:44:55 * eth0
		entries = append(entries, ARPEntry{
			IP:       fields[0],
			MAC:      fields[3],
			Device:   fields[5],
			IsActive: true,
		})
	}
	return entries, nil
}

// regenerateDnsmasqDHCPConfig generates the dnsmasq DHCP configuration file
func regenerateDnsmasqDHCPConfig(store *DHCPConfigStore) error {
	var config strings.Builder

	config.WriteString("# Auto-generated by SoftRouter - DO NOT EDIT MANUALLY\n")
	config.WriteString("# Edit via Web UI: Interfaces > Configure DHCP\n\n")

	for ifaceName, dhcpConf := range store.Configs {
		if !dhcpConf.Enabled {
			continue
		}

		config.WriteString(fmt.Sprintf("# DHCP for %s\n", ifaceName))
		config.WriteString(fmt.Sprintf("interface=%s\n", ifaceName))
		config.WriteString(fmt.Sprintf("dhcp-range=%s,%s,%s,%s\n",
			ifaceName, dhcpConf.StartIP, dhcpConf.EndIP, dhcpConf.LeaseTime))

		// Gateway (option 3)
		if dhcpConf.Gateway != "" {
			config.WriteString(fmt.Sprintf("dhcp-option=%s,3,%s\n", ifaceName, dhcpConf.Gateway))
		}

		// DNS servers (option 6)
		if len(dhcpConf.DNSServers) > 0 {
			config.WriteString(fmt.Sprintf("dhcp-option=%s,6,%s\n", ifaceName, strings.Join(dhcpConf.DNSServers, ",")))
		}

		config.WriteString("\n")
	}

	// Static Leases
	if len(store.StaticLeases) > 0 {
		config.WriteString("# Static Reservations\n")
		for _, lease := range store.StaticLeases {
			// dhcp-host=MAC,IP,HOSTNAME
			config.WriteString(fmt.Sprintf("dhcp-host=%s,%s,%s\n", lease.MAC, lease.IP, lease.Hostname))
		}
	}

	// Ensure directory exists
	os.MkdirAll("/etc/dnsmasq.d", 0755)

	// Write the configuration file
	err := os.WriteFile(dnsmasqDHCPPath, []byte(config.String()), 0644)
	if err != nil {
		return err
	}

	// Restart dnsmasq to apply changes
	runPrivileged("systemctl", "restart", "dnsmasq")

	return nil
}

// parseDHCPLeases reads the dnsmasq leases file
func parseDHCPLeases() ([]DHCPLease, error) {
	leaseFile := "/var/lib/misc/dnsmasq.leases"

	file, err := os.Open(leaseFile)
	if err != nil {
		if os.IsNotExist(err) {
			return []DHCPLease{}, nil // No leases file yet
		}
		return nil, err
	}
	defer file.Close()

	var leases []DHCPLease
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) < 5 {
			continue
		}

		// Format: <expiry> <mac> <ip> <hostname> <client-id>
		expiryTimestamp := fields[0]
		expiryTime := time.Unix(0, 0) // Default
		if ts, err := time.Parse("1136239445", expiryTimestamp); err == nil {
			expiryTime = ts
		} else {
			// Try int parse if timestamp is robust
			var tsInt int64
			fmt.Sscanf(expiryTimestamp, "%d", &tsInt)
			expiryTime = time.Unix(tsInt, 0)
		}

		lease := DHCPLease{
			Expires:   expiryTime.Format("2006-01-02 15:04:05"),
			MAC:       fields[1],
			IP:        fields[2],
			Hostname:  fields[3],
			Interface: "", // dnsmasq doesn't track interface in leases file
		}

		leases = append(leases, lease)
	}

	return leases, scanner.Err()
}

// HTTP Handlers

func getNetworkClients(w http.ResponseWriter, r *http.Request) {
	// 1. Get ARP Table (Live devices)
	arpEntries, _ := getARPTable()

	// 2. Get DHCP Leases (Dynamic history)
	dhcpLeases, _ := parseDHCPLeases()

	// 3. Get Static Leases (Configured)
	store, _ := loadDHCPConfig()

	// Merge logic
	// Map by MAC for deduplication
	clientMap := make(map[string]ARPEntry)

	// Add Static Leases first (Authoritative for config)
	if store != nil {
		for _, static := range store.StaticLeases {
			clientMap[static.MAC] = ARPEntry{
				MAC:      static.MAC,
				IP:       static.IP,
				Hostname: static.Hostname,
				IsStatic: true,
				Device:   "static", // Placeholder
			}
		}
	}

	// Add DHCP Leases (Update IP/Expires if exists, else create)
	for _, lease := range dhcpLeases {
		entry, exists := clientMap[lease.MAC]
		if !exists {
			entry = ARPEntry{
				MAC:      lease.MAC,
				IP:       lease.IP,
				Hostname: lease.Hostname,
			}
		} else {
			// Update dynamic fields if not strictly static overridden IP (though static usually matches)
			if !entry.IsStatic {
				entry.IP = lease.IP
				entry.Hostname = lease.Hostname
			}
		}
		entry.Expires = lease.Expires
		clientMap[lease.MAC] = entry
	}

	// Add ARP Entries (Set IsActive)
	for _, arp := range arpEntries {
		// Ignore incomplete entries
		if arp.MAC == "00:00:00:00:00:00" {
			continue
		}
		entry, exists := clientMap[arp.MAC]
		if !exists {
			entry = arp
			entry.IsStatic = false // Pure ARP = unknown/static config elsewhere or just talking
		} else {
			entry.IsActive = true
			if entry.IP == "" {
				entry.IP = arp.IP // Prefer ARP IP if lease missing
			}
			entry.Device = arp.Device
		}
		clientMap[arp.MAC] = entry
	}

	// Convert map to slice
	clients := make([]ARPEntry, 0, len(clientMap))
	for _, c := range clientMap {
		clients = append(clients, c)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(clients)
}

func addStaticLease(w http.ResponseWriter, r *http.Request) {
	var req StaticLease
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	if req.MAC == "" || req.IP == "" {
		http.Error(w, "MAC and IP required", http.StatusBadRequest)
		return
	}

	store, err := loadDHCPConfig()
	if err != nil {
		http.Error(w, "Failed to load config", http.StatusInternalServerError)
		return
	}

	// Check if already exists, update if so
	found := false
	for i, lease := range store.StaticLeases {
		if lease.MAC == req.MAC {
			store.StaticLeases[i] = req
			found = true
			break
		}
	}
	if !found {
		store.StaticLeases = append(store.StaticLeases, req)
	}

	if err := saveDHCPConfig(store); err != nil {
		http.Error(w, "Failed to save config", http.StatusInternalServerError)
		return
	}

	if err := regenerateDnsmasqDHCPConfig(store); err != nil {
		http.Error(w, "Failed to apply config", http.StatusInternalServerError)
		return
	}

	json.NewEncoder(w).Encode(map[string]string{"status": "success"})
}

func removeStaticLease(w http.ResponseWriter, r *http.Request) {
	mac := r.URL.Query().Get("mac")
	if mac == "" {
		http.Error(w, "MAC address required", http.StatusBadRequest)
		return
	}

	store, err := loadDHCPConfig()
	if err != nil {
		http.Error(w, "Failed to load config", http.StatusInternalServerError)
		return
	}

	newLeases := []StaticLease{}
	for _, lease := range store.StaticLeases {
		if lease.MAC != mac {
			newLeases = append(newLeases, lease)
		}
	}
	store.StaticLeases = newLeases

	if err := saveDHCPConfig(store); err != nil {
		http.Error(w, "Failed to save config", http.StatusInternalServerError)
		return
	}

	if err := regenerateDnsmasqDHCPConfig(store); err != nil {
		http.Error(w, "Failed to apply config", http.StatusInternalServerError)
		return
	}

	json.NewEncoder(w).Encode(map[string]string{"status": "success"})
}

func getDHCPConfig(w http.ResponseWriter, r *http.Request) {
	store, err := loadDHCPConfig()
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to load DHCP config: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(store)
}

func setDHCPConfig(w http.ResponseWriter, r *http.Request) {
	var req struct {
		InterfaceName string     `json:"interfaceName"`
		Config        DHCPConfig `json:"config"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	// Validate interface name
	if !isValidInterfaceName(req.InterfaceName) {
		http.Error(w, "Invalid interface name", http.StatusBadRequest)
		return
	}

	// Validate IP range if enabled
	if req.Config.Enabled {
		if err := validateIPRange(req.InterfaceName, req.Config.StartIP, req.Config.EndIP, req.Config.Gateway); err != nil {
			http.Error(w, fmt.Sprintf("Validation error: %v", err), http.StatusBadRequest)
			return
		}
	}

	// Load existing config
	store, err := loadDHCPConfig()
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to load config: %v", err), http.StatusInternalServerError)
		return
	}

	// Update the configuration
	store.Configs[req.InterfaceName] = req.Config

	// Save to file
	if err := saveDHCPConfig(store); err != nil {
		http.Error(w, fmt.Sprintf("Failed to save config: %v", err), http.StatusInternalServerError)
		return
	}

	// Regenerate dnsmasq config
	if err := regenerateDnsmasqDHCPConfig(store); err != nil {
		http.Error(w, fmt.Sprintf("Failed to update dnsmasq: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"status": "success"})
}

func deleteDHCPConfig(w http.ResponseWriter, r *http.Request) {
	interfaceName := r.URL.Query().Get("interface")
	if interfaceName == "" {
		http.Error(w, "Interface name required", http.StatusBadRequest)
		return
	}

	store, err := loadDHCPConfig()
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to load config: %v", err), http.StatusInternalServerError)
		return
	}

	// Remove the configuration
	delete(store.Configs, interfaceName)

	// Save to file
	if err := saveDHCPConfig(store); err != nil {
		http.Error(w, fmt.Sprintf("Failed to save config: %v", err), http.StatusInternalServerError)
		return
	}

	// Regenerate dnsmasq config
	if err := regenerateDnsmasqDHCPConfig(store); err != nil {
		http.Error(w, fmt.Sprintf("Failed to update dnsmasq: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"status": "success"})
}

func getDHCPLeases(w http.ResponseWriter, r *http.Request) {
	leases, err := parseDHCPLeases()
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to read leases: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(leases)
}
