package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"net"
	"net/http"
	"os"
	"os/exec"
	"strings"
	"time"
)

// loadDHCPConfig loads the DHCP configuration from JSON file
func loadDHCPConfig() (*DHCPConfigStore, error) {
	store := &DHCPConfigStore{
		Configs: make(map[string]DHCPConfig),
	}

	data, err := os.ReadFile(dhcpConfigPath)
	if err != nil {
		if os.IsNotExist(err) {
			// File doesn't exist yet, return empty store
			return store, nil
		}
		return nil, err
	}

	if err := json.Unmarshal(data, store); err != nil {
		return nil, err
	}

	return store, nil
}

// saveDHCPConfig saves the DHCP configuration to JSON file
func saveDHCPConfig(store *DHCPConfigStore) error {
	data, err := json.MarshalIndent(store, "", "  ")
	if err != nil {
		return err
	}

	// Ensure directory exists
	os.MkdirAll("/etc/softrouter", 0755)

	return os.WriteFile(dhcpConfigPath, data, 0644)
}

// validateIPRange checks if the IP range is valid and within the interface subnet
func validateIPRange(interfaceName, startIP, endIP, gateway string) error {
	// Get interface IP to determine subnet
	iface, err := net.InterfaceByName(interfaceName)
	if err != nil {
		return fmt.Errorf("interface not found: %v", err)
	}

	addrs, err := iface.Addrs()
	if err != nil || len(addrs) == 0 {
		return fmt.Errorf("interface has no IP address assigned")
	}

	// Find the first IPv4 address
	var interfaceNet *net.IPNet
	for _, addr := range addrs {
		if ipnet, ok := addr.(*net.IPNet); ok && ipnet.IP.To4() != nil {
			interfaceNet = ipnet
			break
		}
	}

	if interfaceNet == nil {
		return fmt.Errorf("interface has no IPv4 address")
	}

	// Parse and validate IPs
	startIPParsed := net.ParseIP(startIP)
	endIPParsed := net.ParseIP(endIP)
	gatewayParsed := net.ParseIP(gateway)

	if startIPParsed == nil || endIPParsed == nil || gatewayParsed == nil {
		return fmt.Errorf("invalid IP address format")
	}

	// Check if IPs are in the subnet
	if !interfaceNet.Contains(startIPParsed) {
		return fmt.Errorf("start IP %s is not in interface subnet %s", startIP, interfaceNet.String())
	}
	if !interfaceNet.Contains(endIPParsed) {
		return fmt.Errorf("end IP %s is not in interface subnet %s", endIP, interfaceNet.String())
	}
	if !interfaceNet.Contains(gatewayParsed) {
		return fmt.Errorf("gateway %s is not in interface subnet %s", gateway, interfaceNet.String())
	}

	return nil
}

// regenerateDnsmasqDHCPConfig generates the dnsmasq DHCP configuration file
func regenerateDnsmasqDHCPConfig(store *DHCPConfigStore) error {
	var config strings.Builder

	config.WriteString("# Auto-generated by SoftRouter - DO NOT EDIT MANUALLY\n")
	config.WriteString("# Edit via Web UI: Interfaces > Configure DHCP\n\n")

	for ifaceName, dhcpConf := range store.Configs {
		if !dhcpConf.Enabled {
			continue
		}

		config.WriteString(fmt.Sprintf("# DHCP for %s\n", ifaceName))
		config.WriteString(fmt.Sprintf("interface=%s\n", ifaceName))
		config.WriteString(fmt.Sprintf("dhcp-range=%s,%s,%s,%s\n",
			ifaceName, dhcpConf.StartIP, dhcpConf.EndIP, dhcpConf.LeaseTime))

		// Gateway (option 3)
		if dhcpConf.Gateway != "" {
			config.WriteString(fmt.Sprintf("dhcp-option=%s,3,%s\n", ifaceName, dhcpConf.Gateway))
		}

		// DNS servers (option 6)
		if len(dhcpConf.DNSServers) > 0 {
			config.WriteString(fmt.Sprintf("dhcp-option=%s,6,%s\n", ifaceName, strings.Join(dhcpConf.DNSServers, ",")))
		}

		config.WriteString("\n")
	}

	// Ensure directory exists
	os.MkdirAll("/etc/dnsmasq.d", 0755)

	// Write the configuration file
	err := os.WriteFile(dnsmasqDHCPPath, []byte(config.String()), 0644)
	if err != nil {
		return err
	}

	// Restart dnsmasq to apply changes
	exec.Command("systemctl", "restart", "dnsmasq").Run()

	return nil
}

// parseDHCPLeases reads the dnsmasq leases file
func parseDHCPLeases() ([]DHCPLease, error) {
	leaseFile := "/var/lib/misc/dnsmasq.leases"

	file, err := os.Open(leaseFile)
	if err != nil {
		if os.IsNotExist(err) {
			return []DHCPLease{}, nil // No leases file yet
		}
		return nil, err
	}
	defer file.Close()

	var leases []DHCPLease
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)

		if len(fields) < 5 {
			continue
		}

		// Format: <expiry> <mac> <ip> <hostname> <client-id>
		expiryTimestamp := fields[0]
		expiryTime := time.Unix(0, 0) // Default
		if ts, err := time.Parse("1136239445", expiryTimestamp); err == nil {
			expiryTime = ts
		}

		lease := DHCPLease{
			Expires:   expiryTime.Format("2006-01-02 15:04:05"),
			MAC:       fields[1],
			IP:        fields[2],
			Hostname:  fields[3],
			Interface: "", // dnsmasq doesn't track interface in leases file
		}

		leases = append(leases, lease)
	}

	return leases, scanner.Err()
}

// HTTP Handlers

func getDHCPConfig(w http.ResponseWriter, r *http.Request) {
	store, err := loadDHCPConfig()
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to load DHCP config: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(store)
}

func setDHCPConfig(w http.ResponseWriter, r *http.Request) {
	var req struct {
		InterfaceName string     `json:"interfaceName"`
		Config        DHCPConfig `json:"config"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	// Validate interface name
	if !isValidInterfaceName(req.InterfaceName) {
		http.Error(w, "Invalid interface name", http.StatusBadRequest)
		return
	}

	// Validate IP range if enabled
	if req.Config.Enabled {
		if err := validateIPRange(req.InterfaceName, req.Config.StartIP, req.Config.EndIP, req.Config.Gateway); err != nil {
			http.Error(w, fmt.Sprintf("Validation error: %v", err), http.StatusBadRequest)
			return
		}
	}

	// Load existing config
	store, err := loadDHCPConfig()
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to load config: %v", err), http.StatusInternalServerError)
		return
	}

	// Update the configuration
	store.Configs[req.InterfaceName] = req.Config

	// Save to file
	if err := saveDHCPConfig(store); err != nil {
		http.Error(w, fmt.Sprintf("Failed to save config: %v", err), http.StatusInternalServerError)
		return
	}

	// Regenerate dnsmasq config
	if err := regenerateDnsmasqDHCPConfig(store); err != nil {
		http.Error(w, fmt.Sprintf("Failed to update dnsmasq: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"status": "success"})
}

func deleteDHCPConfig(w http.ResponseWriter, r *http.Request) {
	interfaceName := r.URL.Query().Get("interface")
	if interfaceName == "" {
		http.Error(w, "Interface name required", http.StatusBadRequest)
		return
	}

	store, err := loadDHCPConfig()
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to load config: %v", err), http.StatusInternalServerError)
		return
	}

	// Remove the configuration
	delete(store.Configs, interfaceName)

	// Save to file
	if err := saveDHCPConfig(store); err != nil {
		http.Error(w, fmt.Sprintf("Failed to save config: %v", err), http.StatusInternalServerError)
		return
	}

	// Regenerate dnsmasq config
	if err := regenerateDnsmasqDHCPConfig(store); err != nil {
		http.Error(w, fmt.Sprintf("Failed to update dnsmasq: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"status": "success"})
}

func getDHCPLeases(w http.ResponseWriter, r *http.Request) {
	leases, err := parseDHCPLeases()
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to read leases: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(leases)
}
