package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strings"
	"sync"
)

// DynamicRoutingConfig holds the state for OSPF and BGP
type DynamicRoutingConfig struct {
	OSPF OSPFConfig `json:"ospf"`
	BGP  BGPConfig  `json:"bgp"`
}

type OSPFConfig struct {
	Enabled      bool      `json:"enabled"`
	RouterID     string    `json:"router_id"`
	Redistribute []string  `json:"redistribute"` // connected, kernel, static
	Networks     []OSPFNet `json:"networks"`
}

type OSPFNet struct {
	Network string `json:"network"` // CIDR
	Area    string `json:"area"`
}

type BGPConfig struct {
	Enabled   bool          `json:"enabled"`
	ASN       int           `json:"asn"`
	RouterID  string        `json:"router_id"`
	Neighbors []BGPNeighbor `json:"neighbors"`
	Networks  []string      `json:"networks"` // CIDRs to advertise
}

type BGPNeighbor struct {
	IP        string `json:"ip"`
	RemoteASN int    `json:"remote_asn"`
}

var (
	drConfig      DynamicRoutingConfig
	drLock        sync.RWMutex
	drConfigPath  = "/etc/softrouter/dynamic_routing.json"
	frrConfigPath = "/etc/frr/frr.conf"
)

func initDynamicRouting() {
	loadDRConfig()
	// Optionally re-apply on boot?
	// generateFRRConfig()
}

func loadDRConfig() {
	drLock.Lock()
	defer drLock.Unlock()

	data, err := os.ReadFile(drConfigPath)
	if err != nil {
		if os.IsNotExist(err) {
			// Defaults
			drConfig = DynamicRoutingConfig{
				OSPF: OSPFConfig{Enabled: false, Redistribute: []string{"connected"}},
				BGP:  BGPConfig{Enabled: false, ASN: 65000},
			}
			return
		}
		fmt.Printf("Error loading DR config: %v\n", err)
		return
	}
	if err := json.Unmarshal(data, &drConfig); err != nil {
		fmt.Printf("WARNING: Failed to unmarshal dynamic routing config: %v\n", err)
	}
}

func saveDRConfig() error {
	drLock.RLock()
	data, err := json.MarshalIndent(drConfig, "", "  ")
	drLock.RUnlock()
	if err != nil {
		return err
	}
	return os.WriteFile(drConfigPath, data, 0644)
}

// buildFRRConfigString generates the config content without side effects
func buildFRRConfigString(config DynamicRoutingConfig) string {
	var sb strings.Builder

	sb.WriteString("! FRR Config generated by SoftRouter\n")
	sb.WriteString("frr version 8.1\n")
	sb.WriteString("frr defaults traditional\n")
	sb.WriteString("hostname softrouter\n")
	sb.WriteString("log syslog informational\n")
	sb.WriteString("service integrated-vtysh-config\n")
	sb.WriteString("!\n")

	// OSPF
	if config.OSPF.Enabled {
		sb.WriteString("router ospf\n")
		if config.OSPF.RouterID != "" {
			sb.WriteString(fmt.Sprintf(" ospf router-id %s\n", config.OSPF.RouterID))
		}
		for _, net := range config.OSPF.Networks {
			// network <CIDR> area <AREA>
			sb.WriteString(fmt.Sprintf(" network %s area %s\n", net.Network, net.Area))
		}
		for _, redis := range config.OSPF.Redistribute {
			sb.WriteString(fmt.Sprintf(" redistribute %s\n", redis))
		}
		sb.WriteString("!\n")
	}

	// BGP
	if config.BGP.Enabled {
		sb.WriteString(fmt.Sprintf("router bgp %d\n", config.BGP.ASN))
		if config.BGP.RouterID != "" {
			sb.WriteString(fmt.Sprintf(" bgp router-id %s\n", config.BGP.RouterID))
		}
		for _, neighbor := range config.BGP.Neighbors {
			sb.WriteString(fmt.Sprintf(" neighbor %s remote-as %d\n", neighbor.IP, neighbor.RemoteASN))
		}
		sb.WriteString(" !\n")
		sb.WriteString(" address-family ipv4 unicast\n")
		for _, net := range config.BGP.Networks {
			sb.WriteString(fmt.Sprintf("  network %s\n", net))
		}
		sb.WriteString(" exit-address-family\n")
		sb.WriteString("!\n")
	}

	return sb.String()
}

// generateFRRConfig builds the text file for FRR and reloads the service
func generateFRRConfig() error {
	drLock.RLock()
	config := drConfig
	drLock.RUnlock()

	configStr := buildFRRConfigString(config)

	// Write to file
	// Note: In a real system, we must ensure permissions are correct (frr:frr usually)
	// For simplicity, we write as root and try to chown if needed, or rely on service restart to pick it up.
	err := os.WriteFile(frrConfigPath, []byte(configStr), 0640)
	if err != nil {
		return err
	}

	// Reload FRR
	// "systemctl reload frr" is standard
	if out, err := runPrivilegedCombinedOutput("systemctl", "reload", "frr"); err != nil {
		// Fallback to restart if reload fails
		if err := runPrivileged("systemctl", "restart", "frr"); err != nil {
			fmt.Printf("ERROR: Failed to restart FRR: %v\n", err)
		}
		return fmt.Errorf("reload failed: %s", string(out))
	}

	return nil
}

// --- Handlers ---

func getDynamicRouting(w http.ResponseWriter, r *http.Request) {
	drLock.RLock()
	data := drConfig
	drLock.RUnlock()
	w.Header().Set("Content-Type", "application/json")
	writeJSON(w, data)
}

func updateDynamicRouting(w http.ResponseWriter, r *http.Request) {
	var req DynamicRoutingConfig
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	drLock.Lock()
	drConfig = req
	drLock.Unlock()

	if err := saveDRConfig(); err != nil {
		fmt.Printf("WARNING: Failed to save dynamic routing config: %v\n", err)
	}

	if err := generateFRRConfig(); err != nil {
		http.Error(w, "Failed to apply FRR config: "+err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	writeJSON(w, map[string]string{"status": "applied"})
}
